[{"title":"MiHo-主题安装和配置详情","date":"2999-11-29T16:00:00.000Z","path":"2999/11/30/installation-configuration/","text":"一. 主题简介&emsp;&emsp;MiHo 是一款单栏响应式的Hexo主题；基于 Hexo 3.0+ 制作，兼容移动端浏览；主题的代码托管在GitHub上，欢迎Star和Fork；如遇到问题或发表建议，可以提Issues，也可以在博客中留言给我，另外,喜欢的话不妨给个 Star。 二. 安装2.1 安装主题1$ git clone https://github.com/WongMinHo/hexo-theme-miho.git themes/miho MiHo 主题需要Hexo 3.0或以上版本，请先升级。 2.2 更新12cd themes/mihogit pull 2.3 依赖安装如下依赖如果已经安装，请看配置介绍。 Json-content生成站点文章静态数据，用于站内搜索。1npm install hexo-generator-json-content --save 三. 站点配置站点配置文件_config.yml在hexo根目录下。 3.1 启用主题1`theme: miho` 3.2 网站基本配置以下配置是站点的全局配置，更多配置，请查看123456title: MinHow's Blogsubtitle: 网站副标题description: 专注 WEB 开发的技术博客author: MinHowlanguage: 网站使用的语言timezone: 网站时区 3.3 jsonContent配置详细的配置请查看hexo-generator-json-content123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: false 四. 主题配置编辑主题配置文件，themes/miho/_config.yml。 4.1 属性下面将介绍几个比较重要的配置。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122# hexo-theme-miho# https://github.com/wongminho/hexo-theme-miho# Favicon of your site | 网站iconfavicon: /favicon.ico# Header# Keywords of your site | 网站关键字keywords: MinHow,MinHow's Blog# Head headline | 头部标题header_title: MinHow's Blog# Head description | 头部描述header_description: 一个专注 WEB 开发的技术博客# Link to your logo | logo地址logo: images/logo.png# Link to your banner_img | 首页banner图地址banner_img: images/banner.jpg# Menu setting | 菜单设置# name: Font Awesome icon | Font Awesome 图标# title: Home Title | 标题# url: //minhow.com Url, absolute or relative path | 链接，绝对或相对路径# target: true Whether to jump out | 是否跳出menu: home: title: Home url: / target: false archive: title: Archives url: /archives target: false user: title: About url: /about target: false# Social setting, use to display social information | 社交设置，用来展示社交信息# name: Font Awesome icon | Font Awesome 图标# title: Home Icon title | 图标标题# url: //minhow.com Url, absolute or relative path | 链接，绝对或相对路径# target: true Whether to jump out | 是否跳出social: home: title: MinHow url: //minhow.com target: true github: title: Github url: //github.com/wongminho target: true weibo: title: Weibo url: //weibo.com/WongMinHo target: true twitter: title: Twitter url: //twitter.com/huangminhow target: true #qq: #weixin: #snapchat: #telegram: #mail: #facebook: #google: #linkedin:# Content# Excerpt length | 摘录长度excerpt_length: 190# Excerpt link | 摘录链接excerpt_link: more&gt;&gt;# New window open link | 新窗口打开文章open_new_link: false# Article default cover picture，size：350*150 | 文章默认封面图，尺寸：350*150cover_picture: images/banner.jpg# Open background particles | 开启背景粒子open_bg_particle: true# Open animation in homepage and head | 开启主页及头部动画open_animation: true# Article# Open toc | 是否开启toctoc: true# Open share | 是否开启分享share: true# Style customization | 样式定制style: # Main color tone | 主色调 main_color: '#0cc'# Comments | 评论# 畅言，输入appid和appkeychangyan_appid: falsechangyan_appkey: false# 友言，输入idyouyan_id: false# disqusdisqus: false# Analytics | 分析# 站长分析，输入站点idcnzz_analytics: false# 百度分析，输入key值baidu_analytics: false# google analytics | google分析google_analytics: false# Footer# Access statistics | “不蒜子”访问量统计access_counter: on: true site_uv: 总访客数： site_pv: 总访问量：# Copyright Information | 版权信息copyright: 2017 MinHow 4.2 文章封面图文章默认封面图，尺寸：350*150，当文章基本配置没有cover_picture时才显示。1cover_picture: images/banner.jpg 4.3 开启背景粒子是否开启背景粒子。1open_bg_particle: true 4.4 开启主页及头部动画是否开启主页及头部动画。1open_animation: true 4.5 评论支持畅言、disqus。1234567# 畅言，输入appid和appkeychangyan_appid: falsechangyan_appkey: false# 友言，输入idyouyan_id: false# disqusdisqus: false 4.6 数据统计支持站长、百度、google三种数据统计，正确填写配置信息即可。123456# 站长分析，输入站点idcnzz_analytics: false# 百度分析，输入key值baidu_analytics: false# google分析google_analytics: false 4.7 文章基本配置123456789101112---title: Hello Worlddate: 2017-06-18categories: Firstauthor: MinHowtags: - First - Secondcover_picture: /images/banner.jpg--- MinHow-This is a summary&lt;!-- more --&gt; 说明： 需要注意tags和摘要的写法，不然首页不能正确显示标签和摘要； cover_picture文章封面图，不填默认显示_config.yml配置的图片。"},{"title":"angular组件之间的通讯","date":"2019-03-03T04:50:59.000Z","path":"2019/03/03/angular组件之间的通讯/","text":"angluar 组件之间如何联系，根据不同业务和功能等的需求，选择高效的通讯方式 父→子 input&lt;child [conent]=&quot;i&quot;&gt;&lt;/child&gt; @Input() conent: any; 子→父 output&lt;child (sendSum)=&quot;getChildSum($event)&quot;&gt;&lt;/child&gt; @Output() sendSum: EventEmitter&lt;any&gt; = new EventEmitter(); onStart(): void { this.sendSum.emit(any); } 子获得父实例constructor( @Host() @Inject(forwardRef(() =&gt; Parent)) parent: Parent) { console.log(parent); } constructor( @Inject(Parent) private parent: any) { console.log(parent); } 父获得子实例@ViewChild(ChildPage) child:ChildPage; serviceexport class Service { i:number = 0; } EventEmitter1.EventEmitterchange: EventEmitter&lt;number&gt;; constructor(){ this.change = new EventEmitter(); } constructor(private service:Service) { service.change.emit(++this.i); } 2.EventEmitter3public _event; constructor() { this._event = new eventemitter3(); } ngOnInit() { this.eventService._event.on(&apos;sendNum&apos;, this.acceptNum, this); } public acceptNum(num) { console.log(num); } this.eventService._event.emit(&apos;sendNum, this.num); 订阅1.Subjectimport { Subject } from &apos;rxjs/Subject&apos;; private Source=new Subject&lt;any&gt;(); Status$=this.Source.asObservable(); StatusMission(message: any) { this.Source.next(message); } constructor(public service:myService) { setInterval(()=&gt; { this.service.StatusMission(this.i++); }, 1000) } subscription: Subscription; constructor(private Service: myService) { this.subscription = Service.Status$.subscribe(message =&gt; { this.i=message; }); } ngOnDestroy() { this.subscription.unsubscribe(); } 2.ReplaySubjectimport {ReplaySubject} from &quot;rxjs/ReplaySubject&quot;; private _sendMessage: ReplaySubject&lt;any&gt; = new ReplaySubject&lt;any&gt;; public sendMessage(message: any): Observavle&lt;any&gt;{ this._sendMessage.next(message); } public getMessage(): Observable &lt;any&gt;{ return this._sendMessage.asObservable(); } this.communicateService.sendMessage(&apos;send a message&apos;); this.communicateService.getMessage().subscribe((message: any)=&gt;{ console.log(message); }) 路由传值import { Router } from &apos;@angular/router&apos;; import { ActivatedRoute, Params } from &apos;@angular/router&apos;; constructor(private router: Router,private route: ActivatedRoute,) { } &lt;button [routerLink]=&quot;[&apos;/about&apos;,1]&quot;&gt;跳转&lt;/button&gt; &lt;button [routerLink]=&quot;[&apos;/about&apos;,&quot;home&quot;]&quot;&gt;跳转&lt;/button&gt; this.id = this.route.snapshot.params[&apos;id&apos;]; this.router.navigate([&apos;/about&apos;], { queryParams: { id: &apos;1&apos;, status: true } }); this.route.queryParams.subscribe((params: Params) =&gt; { this.id = params[&apos;id&apos;]; this.status = params[&apos;status&apos;]; }) localstoragewindow.localStorage.setItem(&quot;test&quot;, JSON.stringify({ key: &apos;test&apos;, value: 1 })); const obj = JSON.parse(window.localStorage.getItem(&quot;test&quot;));"},{"title":"TS学习之类","date":"2019-03-01T16:57:18.000Z","path":"2019/03/02/TS学习之类/","text":"定义类1234567891011class Person &#123; name: string; //属性 constructor(_name: string) &#123; this.name = _name; &#125; //构造函数 sayHello(): string &#123; return \"Hi,everyone\" &#125; //方法&#125;let firstOne = new Person(\"Fred\") //实例化类 继承继承使用关键字extends，调用父类使用super，子类继承父类的属性和方法，并且子类可以改写父类的属性和方法12345678910111213141516171819202122class Animal &#123; name: string; constructor(_name: string) &#123; this.name = _name; &#125; skinColour(color: string = \"black\"): void &#123; console.log(`$&#123;this.name&#125; skin colour is $&#123;color&#125;`) &#125;&#125;class Horse extends Animal &#123; constructor(name: string) &#123; super(name) &#125; skinColour(color: string = \"brown\"): void &#123; console.log(`I'am $&#123;this.name&#125;`); super.skinColour(\"brown\"); &#125;&#125;let horse = new Horse(\"horse\");horse.skinColour()// I'am horse// horse skin colour is brown public、private、protected、readonlypublic（不声明默认都为public，也可以显示的设置为public）12345678910class Person &#123; public name: string; //属性 public constructor(_name: string) &#123; this.name = _name; &#125; //构造函数 public sayHello(): string &#123; return \"Hi,everyone\" &#125; //方法&#125;let firstOne = new Person(\"Fred\") //实例化类 private（private的成员不能被外部访问；比较带有private或protected成员的类型时，两个类型兼容的条件是private或protected的成员必须相同切来至同一个声明（同一个类））123456789101112131415161718class Person &#123; private name: string; public constructor(_name: string) &#123; this.name = _name; &#125; &#125;class Employee &#123; private name: string; public constructor(_name: string) &#123; this.name = _name; &#125; &#125;let firstOne = new Person(\"Fred\")console.log(firstOne.name) //error: Property 'name' is private;let lastOne = new Employee(\"Fred\")firstOne = lastOne // error: Type 'Employee' is not assignable to type 'Person'.Types have separate declarations of a private property 'name'. protected（protected和private相似，但protected成员可以在派生类中访问（能被继承，但不能在实例中访问，若构造函数是protected，则不能被实例化，只能被继承））123456789101112131415161718class Person &#123; protected name: string; protected constructor(_name: string) &#123; this.name = _name; &#125; &#125;class Employee extends Person &#123; private department: string; public constructor(name: string,department:string) &#123; super(name); this.department = department; &#125; &#125;let Bob = new Person; //error: Constructor of class 'Person' is protectedlet fred = new Employee(\"fred\",\"test\");console.log(fred.name) //error: Property 'name' is protected readonly（设置属性为只读，必须在声明时或构造函数里初始化）123456789class Person &#123; readonly name: string; constructor(_name: string) &#123; this.name = _name; &#125; &#125;let fred = new Person(\"fred\");fred.name = \"Bob\" //error: Cannot assign to 'name' because it is a constant or a read-only property. 参数属性参数属性通过给构造函数参数添加一个访问限定符来声明（public,private,protected）,把声明和赋值合并至一处123456789class Person &#123; constructor(private name: string) &#123; &#125; sayHello(): void &#123; console.log(`my name is $&#123;this.name&#125;`) &#125;&#125;let fred = new Person(\"fred\");fred.sayHello() //my name is fred 存取器get、set 只带有 get不带有set的存取器自动被推断为readonly123456789101112131415161718192021222324let passcode = \"secret passcode\";class Employee &#123; private _fullName: string; get fullName(): string &#123; return this._fullName; &#125; set fullName(newName: string) &#123; if (passcode &amp;&amp; passcode == \"secret passcode\") &#123; this._fullName = newName; &#125; else &#123; console.log(\"Error: Unauthorized update of employee!\"); &#125; &#125;&#125;let employee = new Employee();employee.fullName = \"Bob Smith\";if (employee.fullName) &#123; console.log(employee.fullName);&#125; 静态属性static，不能被实例访问，在类里面访问时，需要加上类名12345678910class Person &#123; static height:number = 180; constructor(private name: string) &#123; &#125; sayHello(): void &#123; console.log(`my name is $&#123;this.name&#125;, I height is $&#123;Person.height&#125;`) &#125;&#125;let fred = new Person(\"fred\");fred.sayHello() //my name is fred, I height is 180 抽象类abstract，抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。抽象类中的抽象方法不包含具体实现并且必须在派生类中实现12345678910111213141516abstract class Person &#123; constructor(public name: string) &#123; &#125; abstract sayHello():void;&#125;class Empoloy extends Person&#123; constructor()&#123; super(\"Fred\") &#125; sayHello()&#123; console.log(`my name is $&#123;this.name&#125;`) &#125;&#125;let firstOne = new Empoloy();firstOne.sayHello(); //my name is Fred"},{"title":"团队协作","date":"2018-11-05T02:12:07.000Z","path":"2018/11/05/团队协作/","text":"随想随记有时候突然会想一些东西,以前是有准备一个小小的笔记本的,用来记录这些随时想起来的事情.不过不知不觉本子就不知放到哪里了.虽然不一定会再去翻看那些曾经写过的东西,也不一定记得写过什么,不过还是想把这些记下来! 有时候在想问题的时候,直接面对真实的事情内容,不一定做出很有效率的解决办法.往往可以借助比喻的手段把问题点本质化,就像扫除杂叶,只留精华和本质.真正的能力是是否能够准确地去比喻和形象化要思考的事情. 反思还是有必要的,把之前做的不足的地方,想想哪里做的不太合适.虽然咱们不是十全十美,但也应该去力所能及的把事情做好,这样才可能每次跟好.追求不必很高,只求每次好一点点."},{"title":"http协议为什么要区分 post,get,put,delete","date":"2018-10-31T02:28:27.000Z","path":"2018/10/31/http协议为什么要区分-post-get-put-delete/","text":"工作当中，当后端换人之后，写的接口风格会有所变化，虽然是个人的习惯，但对团队项目来说并不友善。 所有 http 请求，一律用 POST,在业务功能的实现是没有问题的.post,get,put,delete 是标准, 大家都遵循这样的规则. 这样的api对于它人来说一目了然, get就是获取数据, post就是提交数据, put就是更新数据, delete就做删除操作. 如果一律使用post对一个项目组的内部人员来说是没有问题的, 但是对于对外公开的接口就让调用者摸不着头脑了.另外这四种方法还有特殊的用意.GET 请求可被缓存, 请求可保留在浏览器历史记录中, 请求可被收藏为书签, get方法具有Safe特性会影响是否可以快取(post不支持快取)POST 请求不会被缓存, 请求不会保留在浏览器历史记录中, 不能被收藏为书签这就是为什么取数据要使用get而不是post. 因为get可以快取, 缓存和保留历史记录及书签等特殊功能.除了上面的4种常见方法还有一个很重要的方法PATCH. RESTFUL API 设计规范了解下 segmentfault 阮一峰的网络日志"},{"title":"js编写chrome插件","date":"2018-10-11T03:35:21.000Z","path":"2018/10/11/js编写chrome插件/","text":"chrome占用了大部分用电脑的时间,用自定义的chrome插件可以大大提高效率"},{"title":"My study habits","date":"2018-10-09T16:00:00.000Z","path":"2018/10/10/My-study-habits/","text":"前言&emsp;&emsp;刚开始接触博客，记录一下工作和生活中感觉有用的资料、方法和体会等!以前都是做笔记和在浏览器便签等方法来记录,当然这些也还在用。慢慢会筛选一些内容迁移到博客里，一是可以用做分享，二是可以在编写过程中加深理解。所有内容包括从其他文章看到和通过自己的理解在重新整理和归纳，并在有新的认识的时候会在原有基础上做随时更新。准确度上自我判断，本人并不负责。希望大家能够提供宝贵意见，我将十分感激。 &emsp;&emsp;目前时间端的一些习惯，也会随时根据个人情况做更改。把习惯记录一下，看到的时候会提醒一下有些什么事还没做。 &emsp;&emsp;还有个目的，刚接触markdown,就当练手啦!嘎嘎! 方法 英语的学习，每天看些，如果要想在行业内有更远的发展，英语会成为不可缺少的条件！ 每天浏览的网站主要是segmentfault和csdn，会花少量时间关注一下感兴趣的文章，坚持下去，日积月累，是会有收获的！ 坚持写文章，把掌握的知识表达出来，目前定的计划是一周两三篇吧！ 技能、学术性等的搜索一般用google，技术问题在Stack Overflow上能解决大部分! 当然做主要的还是工作了，确保工作之余探索和保持一个效率更高的习惯！ 未完待续，持续更新"},{"title":"angular2、4为元素绑定事件","date":"2018-10-09T10:05:55.000Z","path":"2018/10/09/angular2、4为元素绑定事件/","text":"angular中获取DOM并绑定事件,对DOM操作。 代码1234567891011121314` constructor(private _api: ApiRequest, private _cookie: CookieService, public element: ElementRef, public renderer2: Renderer2, private _commonService: CommonService, private _router: Router) &#123;&#125;` `let btn3=this.element.nativeElement.querySelector('#btn3'); this.renderer2.listen(btn3,\"click\",()=&gt; &#123; //this.renderer2.setStyle(ul, \"background\", \"blue\"); alert(22222); &#125;)"},{"title":"Hello World","date":"2018-06-09T10:05:55.000Z","path":"2018/06/09/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]